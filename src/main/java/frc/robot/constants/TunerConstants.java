package frc.robot.constants;

import com.ctre.phoenix6.configs.Slot0Configs;
import com.ctre.phoenix6.mechanisms.swerve.SwerveDrivetrainConstants;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstants;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstantsFactory;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModule.ClosedLoopOutputType;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstants.SteerFeedbackType;

import edu.wpi.first.math.util.Units;
import frc.robot.subsystems.CommandSwerveDrivetrain;

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
public class TunerConstants {
    // Both sets of gains need to be tuned to your individual robot.

    // The steer motor uses any SwerveModule.SteerRequestType control request with the
    // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
    private static final Slot0Configs steerGains = new Slot0Configs()
        .withKP(RobotMap.DrivetrainConstants.STEER_GAINS.kP)
        .withKI(RobotMap.DrivetrainConstants.STEER_GAINS.kI)
        .withKD(RobotMap.DrivetrainConstants.STEER_GAINS.kD)
        .withKS(RobotMap.DrivetrainConstants.STEER_GAINS.kS)
        .withKV(RobotMap.DrivetrainConstants.STEER_GAINS.kV)
        .withKA(RobotMap.DrivetrainConstants.STEER_GAINS.kA);

    // When using closed-loop control, the drive motor uses the control
    // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
    private static final Slot0Configs driveGains = new Slot0Configs()
        .withKP(RobotMap.DrivetrainConstants.DRIVE_GAINS.kP)
        .withKI(RobotMap.DrivetrainConstants.DRIVE_GAINS.kI)
        .withKD(RobotMap.DrivetrainConstants.DRIVE_GAINS.kD)
        .withKS(RobotMap.DrivetrainConstants.DRIVE_GAINS.kS)
        .withKV(RobotMap.DrivetrainConstants.DRIVE_GAINS.kV)
        .withKA(RobotMap.DrivetrainConstants.DRIVE_GAINS.kA);

    // The closed-loop output type to use for the steer motors;
    // This affects the PID/FF gains for the steer motors
    private static final ClosedLoopOutputType steerClosedLoopOutput = ClosedLoopOutputType.Voltage;
    // The closed-loop output type to use for the drive motors;
    // This affects the PID/FF gains for the drive motors
    private static final ClosedLoopOutputType driveClosedLoopOutput = ClosedLoopOutputType.Voltage;

    // The stator current at which the wheels start to slip;
    // This needs to be tuned to your individual robot
    private static final double kSlipCurrentA = 300.0;

    // Every 1 rotation of the azimuth results in kCoupleRatio drive motor turns;
    // This may need to be tuned to your individual robot
    private static final double kCoupleRatio = 3.5;

    private static final double kWheelRadiusInches = 2.0; // Estimated at first, then fudge-factored to make odom match record

    private static final String kCANbusName = "rio";

    // These are only used for simulation
    private static final double kSteerInertia = 0.00001;
    private static final double kDriveInertia = 0.001;
    // Simulated voltage necessary to overcome friction
    private static final double kSteerFrictionVoltage = 0.25;
    private static final double kDriveFrictionVoltage = 0.25;

    private static final SwerveDrivetrainConstants DrivetrainConstants = new SwerveDrivetrainConstants()
            .withPigeon2Id(RobotMap.DrivetrainConstants.PIGEON_CAN_ID)
            .withCANbusName(kCANbusName);

    private static final SwerveModuleConstantsFactory ConstantCreator = new SwerveModuleConstantsFactory()
            .withDriveMotorGearRatio(RobotMap.DrivetrainConstants.DRIVE_GEAR_RATIO)
            .withSteerMotorGearRatio(RobotMap.DrivetrainConstants.STEER_GEAR_RATION)
            .withWheelRadius(kWheelRadiusInches)
            .withSlipCurrent(kSlipCurrentA)
            .withSteerMotorGains(steerGains)
            .withDriveMotorGains(driveGains)
            .withSteerMotorClosedLoopOutput(steerClosedLoopOutput)
            .withDriveMotorClosedLoopOutput(driveClosedLoopOutput)
            .withSpeedAt12VoltsMps(RobotMap.DrivetrainConstants.SPEED_AT_12V_MPS)
            .withSteerInertia(kSteerInertia)
            .withDriveInertia(kDriveInertia)
            .withSteerFrictionVoltage(kSteerFrictionVoltage)
            .withDriveFrictionVoltage(kDriveFrictionVoltage)
            .withFeedbackSource(SteerFeedbackType.FusedCANcoder)
            .withCouplingGearRatio(kCoupleRatio)
            .withSteerMotorInverted(RobotMap.DrivetrainConstants.STEER_MOTOR_REVERSED);

    private static final SwerveModuleConstants FrontLeft = ConstantCreator.createModuleConstants(
        RobotMap.DrivetrainConstants.FRONT_LEFT_STEER_ID,
        RobotMap.DrivetrainConstants.FRONT_LEFT_DRIVE_ID, 
        RobotMap.DrivetrainConstants.FRONT_LEFT_ENCODER_ID, 
        RobotMap.DrivetrainConstants.FRONT_LEFT_OFFSET, 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.FRONT_LEFT_XPOS_INCHES), 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.FRONT_LEFT_YPOS_INCHES), 
        RobotMap.DrivetrainConstants.INVERT_LEFT_SIDE);
 
    private static final SwerveModuleConstants FrontRight = ConstantCreator.createModuleConstants(
        RobotMap.DrivetrainConstants.FRONT_RIGHT_STEER_ID,
        RobotMap.DrivetrainConstants.FRONT_RIGHT_DRIVE_ID, 
        RobotMap.DrivetrainConstants.FRONT_RIGHT_ENCODER_ID, 
        RobotMap.DrivetrainConstants.FRONT_RIGHT_OFFSET, 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.FRONT_RIGHT_XPOS_INCHES), 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.FRONT_RIGHT_YPOS_INCHES), 
        RobotMap.DrivetrainConstants.INVERT_RIGHT_SIDE);

    private static final SwerveModuleConstants BackLeft = ConstantCreator.createModuleConstants(
        RobotMap.DrivetrainConstants.BACK_LEFT_STEER_ID,
        RobotMap.DrivetrainConstants.BACK_LEFT_DRIVE_ID, 
        RobotMap.DrivetrainConstants.BACK_LEFT_ENCODER_ID, 
        RobotMap.DrivetrainConstants.BACK_LEFT_OFFSET, 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.BACK_LEFT_XPOS_INCHES), 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.BACK_LEFT_YPOS_INCHES), 
        RobotMap.DrivetrainConstants.INVERT_LEFT_SIDE); 

    private static final SwerveModuleConstants BackRight = ConstantCreator.createModuleConstants(
        RobotMap.DrivetrainConstants.BACK_RIGHT_STEER_ID,
        RobotMap.DrivetrainConstants.BACK_RIGHT_DRIVE_ID, 
        RobotMap.DrivetrainConstants.BACK_RIGHT_ENCODER_ID, 
        RobotMap.DrivetrainConstants.BACK_RIGHT_OFFSET, 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.BACK_RIGHT_XPOS_INCHES), 
        Units.inchesToMeters(RobotMap.DrivetrainConstants.BACK_RIGHT_YPOS_INCHES), 
        RobotMap.DrivetrainConstants.INVERT_RIGHT_SIDE);

    public static final CommandSwerveDrivetrain DriveTrain = 
        new CommandSwerveDrivetrain(DrivetrainConstants, FrontLeft, FrontRight, BackLeft, BackRight);
}
